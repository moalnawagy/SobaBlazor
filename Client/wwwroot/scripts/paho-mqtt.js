!function (e, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : "object" == typeof exports ? exports = t() : (void 0 === e.Paho && (e.Paho = {}), e.Paho.MQTT = t()) }(this, function () { return function (e) { function t(e, t) { var s = t, n = e[t], o = n >> 4, r = n &= 15; t += 1; var h, u = 0, d = 1; do { if (t == e.length) return [null, s]; u += (127 & (h = e[t++])) * d, d *= 128 } while (0 != (128 & h)); var l = t + u; if (l > e.length) return [null, s]; var _ = new p(o); switch (o) { case c.CONNACK: 1 & e[t++] && (_.sessionPresent = !0), _.returnCode = e[t++]; break; case c.PUBLISH: var f = r >> 1 & 3, g = i(e, t), I = a(e, t += 2, g); t += g, f > 0 && (_.messageIdentifier = i(e, t), t += 2); var w = new Paho.MQTT.Message(e.subarray(t, l)); 1 == (1 & r) && (w.retained = !0), 8 == (8 & r) && (w.duplicate = !0), w.qos = f, w.destinationName = I, _.payloadMessage = w; break; case c.PUBACK: case c.PUBREC: case c.PUBREL: case c.PUBCOMP: case c.UNSUBACK: _.messageIdentifier = i(e, t); break; case c.SUBACK: _.messageIdentifier = i(e, t), t += 2, _.returnCode = e.subarray(t, l) }return [_, l] } function s(e, t, s) { return t[s++] = e >> 8, t[s++] = e % 256, s } function n(e, t, n, i) { return i = s(t, n, i), r(e, n, i), i + t } function i(e, t) { return 256 * e[t] + e[t + 1] } function o(e) { for (var t = 0, s = 0; s < e.length; s++) { var n = e.charCodeAt(s); n > 2047 ? (55296 <= n && n <= 56319 && (s++ , t++), t += 3) : n > 127 ? t += 2 : t++ } return t } function r(e, t, s) { for (var n = s, i = 0; i < e.length; i++) { var o = e.charCodeAt(i); if (55296 <= o && o <= 56319) { var r = e.charCodeAt(++i); if (isNaN(r)) throw new Error(_(d.MALFORMED_UNICODE, [o, r])); o = r - 56320 + (o - 55296 << 10) + 65536 } o <= 127 ? t[n++] = o : o <= 2047 ? (t[n++] = o >> 6 & 31 | 192, t[n++] = 63 & o | 128) : o <= 65535 ? (t[n++] = o >> 12 & 15 | 224, t[n++] = o >> 6 & 63 | 128, t[n++] = 63 & o | 128) : (t[n++] = o >> 18 & 7 | 240, t[n++] = o >> 12 & 63 | 128, t[n++] = o >> 6 & 63 | 128, t[n++] = 63 & o | 128) } return t } function a(e, t, s) { for (var n, i = "", o = t; o < t + s;) { var r = e[o++]; if (r < 128) n = r; else { var a = e[o++] - 128; if (a < 0) throw new Error(_(d.MALFORMED_UTF, [r.toString(16), a.toString(16), ""])); if (r < 224) n = 64 * (r - 192) + a; else { var c = e[o++] - 128; if (c < 0) throw new Error(_(d.MALFORMED_UTF, [r.toString(16), a.toString(16), c.toString(16)])); if (r < 240) n = 4096 * (r - 224) + 64 * a + c; else { var h = e[o++] - 128; if (h < 0) throw new Error(_(d.MALFORMED_UTF, [r.toString(16), a.toString(16), c.toString(16), h.toString(16)])); if (!(r < 248)) throw new Error(_(d.MALFORMED_UTF, [r.toString(16), a.toString(16), c.toString(16), h.toString(16)])); n = 262144 * (r - 240) + 4096 * a + 64 * c + h } } } n > 65535 && (n -= 65536, i += String.fromCharCode(55296 + (n >> 10)), n = 56320 + (1023 & n)), i += String.fromCharCode(n) } return i } var c = { CONNECT: 1, CONNACK: 2, PUBLISH: 3, PUBACK: 4, PUBREC: 5, PUBREL: 6, PUBCOMP: 7, SUBSCRIBE: 8, SUBACK: 9, UNSUBSCRIBE: 10, UNSUBACK: 11, PINGREQ: 12, PINGRESP: 13, DISCONNECT: 14 }, h = function (e, t) { for (var s in e) if (e.hasOwnProperty(s)) { if (!t.hasOwnProperty(s)) { var n = "Unknown property, " + s + ". Valid properties are:"; for (var i in t) t.hasOwnProperty(i) && (n = n + " " + i); throw new Error(n) } if (typeof e[s] !== t[s]) throw new Error(_(d.INVALID_TYPE, [typeof e[s], s])) } }, u = function (e, t) { return function () { return e.apply(t, arguments) } }, d = { OK: { code: 0, text: "AMQJSC0000I OK." }, CONNECT_TIMEOUT: { code: 1, text: "AMQJSC0001E Connect timed out." }, SUBSCRIBE_TIMEOUT: { code: 2, text: "AMQJS0002E Subscribe timed out." }, UNSUBSCRIBE_TIMEOUT: { code: 3, text: "AMQJS0003E Unsubscribe timed out." }, PING_TIMEOUT: { code: 4, text: "AMQJS0004E Ping timed out." }, INTERNAL_ERROR: { code: 5, text: "AMQJS0005E Internal error. Error Message: {0}, Stack trace: {1}" }, CONNACK_RETURNCODE: { code: 6, text: "AMQJS0006E Bad Connack return code:{0} {1}." }, SOCKET_ERROR: { code: 7, text: "AMQJS0007E Socket error:{0}." }, SOCKET_CLOSE: { code: 8, text: "AMQJS0008I Socket closed." }, MALFORMED_UTF: { code: 9, text: "AMQJS0009E Malformed UTF data:{0} {1} {2}." }, UNSUPPORTED: { code: 10, text: "AMQJS0010E {0} is not supported by this browser." }, INVALID_STATE: { code: 11, text: "AMQJS0011E Invalid state {0}." }, INVALID_TYPE: { code: 12, text: "AMQJS0012E Invalid type {0} for {1}." }, INVALID_ARGUMENT: { code: 13, text: "AMQJS0013E Invalid argument {0} for {1}." }, UNSUPPORTED_OPERATION: { code: 14, text: "AMQJS0014E Unsupported operation." }, INVALID_STORED_DATA: { code: 15, text: "AMQJS0015E Invalid data in local storage key={0} value={1}." }, INVALID_MQTT_MESSAGE_TYPE: { code: 16, text: "AMQJS0016E Invalid MQTT message type {0}." }, MALFORMED_UNICODE: { code: 17, text: "AMQJS0017E Malformed Unicode string:{0} {1}." }, BUFFER_FULL: { code: 18, text: "AMQJS0018E Message buffer is full, maximum buffer size: {0}." } }, l = { 0: "Connection Accepted", 1: "Connection Refused: unacceptable protocol version", 2: "Connection Refused: identifier rejected", 3: "Connection Refused: server unavailable", 4: "Connection Refused: bad user name or password", 5: "Connection Refused: not authorized" }, _ = function (e, t) { var s = e.text; if (t) for (var n, i, o = 0; o < t.length; o++)if (n = "{" + o + "}", (i = s.indexOf(n)) > 0) { var r = s.substring(0, i), a = s.substring(i + n.length); s = r + t[o] + a } return s }, f = [0, 6, 77, 81, 73, 115, 100, 112, 3], g = [0, 4, 77, 81, 84, 84, 4], p = function (e, t) { this.type = e; for (var s in t) t.hasOwnProperty(s) && (this[s] = t[s]) }; p.prototype.encode = function () { var e, t = (15 & this.type) << 4, i = 0, r = [], a = 0; switch (void 0 !== this.messageIdentifier && (i += 2), this.type) { case c.CONNECT: switch (this.mqttVersion) { case 3: i += f.length + 3; break; case 4: i += g.length + 3 }i += o(this.clientId) + 2, void 0 !== this.willMessage && (i += o(this.willMessage.destinationName) + 2, (e = this.willMessage.payloadBytes) instanceof Uint8Array || (e = new Uint8Array(h)), i += e.byteLength + 2), void 0 !== this.userName && (i += o(this.userName) + 2), void 0 !== this.password && (i += o(this.password) + 2); break; case c.SUBSCRIBE: t |= 2; for (I = 0; I < this.topics.length; I++)r[I] = o(this.topics[I]), i += r[I] + 2; i += this.requestedQos.length; break; case c.UNSUBSCRIBE: t |= 2; for (I = 0; I < this.topics.length; I++)r[I] = o(this.topics[I]), i += r[I] + 2; break; case c.PUBREL: t |= 2; break; case c.PUBLISH: this.payloadMessage.duplicate && (t |= 8), t = t |= this.payloadMessage.qos << 1, this.payloadMessage.retained && (t |= 1), i += (a = o(this.payloadMessage.destinationName)) + 2; var h = this.payloadMessage.payloadBytes; i += h.byteLength, h instanceof ArrayBuffer ? h = new Uint8Array(h) : h instanceof Uint8Array || (h = new Uint8Array(h.buffer)); break; case c.DISCONNECT: }var u = function (e) { var t = new Array(1), s = 0; do { var n = e % 128; (e >>= 7) > 0 && (n |= 128), t[s++] = n } while (e > 0 && s < 4); return t }(i), d = u.length + 1, l = new ArrayBuffer(i + d), _ = new Uint8Array(l); if (_[0] = t, _.set(u, 1), this.type == c.PUBLISH) d = n(this.payloadMessage.destinationName, a, _, d); else if (this.type == c.CONNECT) { switch (this.mqttVersion) { case 3: _.set(f, d), d += f.length; break; case 4: _.set(g, d), d += g.length }var p = 0; this.cleanSession && (p = 2), void 0 !== this.willMessage && (p |= 4, p |= this.willMessage.qos << 3, this.willMessage.retained && (p |= 32)), void 0 !== this.userName && (p |= 128), void 0 !== this.password && (p |= 64), _[d++] = p, d = s(this.keepAliveInterval, _, d) } switch (void 0 !== this.messageIdentifier && (d = s(this.messageIdentifier, _, d)), this.type) { case c.CONNECT: d = n(this.clientId, o(this.clientId), _, d), void 0 !== this.willMessage && (d = n(this.willMessage.destinationName, o(this.willMessage.destinationName), _, d), d = s(e.byteLength, _, d), _.set(e, d), d += e.byteLength), void 0 !== this.userName && (d = n(this.userName, o(this.userName), _, d)), void 0 !== this.password && (d = n(this.password, o(this.password), _, d)); break; case c.PUBLISH: _.set(h, d); break; case c.SUBSCRIBE: for (I = 0; I < this.topics.length; I++)d = n(this.topics[I], r[I], _, d), _[d++] = this.requestedQos[I]; break; case c.UNSUBSCRIBE: for (var I = 0; I < this.topics.length; I++)d = n(this.topics[I], r[I], _, d) }return l }; var I = function (e, t, s) { this._client = e, this._window = t, this._keepAliveInterval = 1e3 * s, this.isReset = !1; var n = new p(c.PINGREQ).encode(), i = function (e) { return function () { return o.apply(e) } }, o = function () { this.isReset ? (this.isReset = !1, this._client._trace("Pinger.doPing", "send PINGREQ"), this._client.socket.send(n), this.timeout = this._window.setTimeout(i(this), this._keepAliveInterval)) : (this._client._trace("Pinger.doPing", "Timed out"), this._client._disconnected(d.PING_TIMEOUT.code, _(d.PING_TIMEOUT))) }; this.reset = function () { this.isReset = !0, this._window.clearTimeout(this.timeout), this._keepAliveInterval > 0 && (this.timeout = setTimeout(i(this), this._keepAliveInterval)) }, this.cancel = function () { this._window.clearTimeout(this.timeout) } }, w = function (e, t, s, n, i) { this._window = t, s || (s = 30); this.timeout = setTimeout(function (e, t, s) { return function () { return e.apply(t, s) } }(n, e, i), 1e3 * s), this.cancel = function () { this._window.clearTimeout(this.timeout) } }, v = function (t, s, n, i, o) { if (!("WebSocket" in e && null !== e.WebSocket)) throw new Error(_(d.UNSUPPORTED, ["WebSocket"])); if (!("localStorage" in e && null !== e.localStorage)) throw new Error(_(d.UNSUPPORTED, ["localStorage"])); if (!("ArrayBuffer" in e && null !== e.ArrayBuffer)) throw new Error(_(d.UNSUPPORTED, ["ArrayBuffer"])); this._trace("Paho.MQTT.Client", t, s, n, i, o), this.host = s, this.port = n, this.path = i, this.uri = t, this.clientId = o, this._wsuri = null, this._localKey = s + ":" + n + ("/mqtt" != i ? ":" + i : "") + ":" + o + ":", this._msg_queue = [], this._buffered_msg_queue = [], this._sentMessages = {}, this._receivedMessages = {}, this._notify_msg_sent = {}, this._message_identifier = 1, this._sequence = 0; for (var r in localStorage) 0 !== r.indexOf("Sent:" + this._localKey) && 0 !== r.indexOf("Received:" + this._localKey) || this.restore(r) }; v.prototype.host = null, v.prototype.port = null, v.prototype.path = null, v.prototype.uri = null, v.prototype.clientId = null, v.prototype.socket = null, v.prototype.connected = !1, v.prototype.maxMessageIdentifier = 65536, v.prototype.connectOptions = null, v.prototype.hostIndex = null, v.prototype.onConnected = null, v.prototype.onConnectionLost = null, v.prototype.onMessageDelivered = null, v.prototype.onMessageArrived = null, v.prototype.traceFunction = null, v.prototype._msg_queue = null, v.prototype._buffered_msg_queue = null, v.prototype._connectTimeout = null, v.prototype.sendPinger = null, v.prototype.receivePinger = null, v.prototype._reconnectInterval = 1, v.prototype._reconnecting = !1, v.prototype._reconnectTimeout = null, v.prototype.disconnectedPublishing = !1, v.prototype.disconnectedBufferSize = 5e3, v.prototype.receiveBuffer = null, v.prototype._traceBuffer = null, v.prototype._MAX_TRACE_ENTRIES = 100, v.prototype.connect = function (e) { var t = this._traceMask(e, "password"); if (this._trace("Client.connect", t, this.socket, this.connected), this.connected) throw new Error(_(d.INVALID_STATE, ["already connected"])); if (this.socket) throw new Error(_(d.INVALID_STATE, ["already connected"])); this._reconnecting && (this._reconnectTimeout.cancel(), this._reconnectTimeout = null, this._reconnecting = !1), this.connectOptions = e, this._reconnectInterval = 1, this._reconnecting = !1, e.uris ? (this.hostIndex = 0, this._doConnect(e.uris[0])) : this._doConnect(this.uri) }, v.prototype.subscribe = function (e, t) { if (this._trace("Client.subscribe", e, t), !this.connected) throw new Error(_(d.INVALID_STATE, ["not connected"])); var s = new p(c.SUBSCRIBE); s.topics = [e], void 0 !== t.qos ? s.requestedQos = [t.qos] : s.requestedQos = [0], t.onSuccess && (s.onSuccess = function (e) { t.onSuccess({ invocationContext: t.invocationContext, grantedQos: e }) }), t.onFailure && (s.onFailure = function (e) { t.onFailure({ invocationContext: t.invocationContext, errorCode: e, errorMessage: _(e) }) }), t.timeout && (s.timeOut = new w(this, window, t.timeout, t.onFailure, [{ invocationContext: t.invocationContext, errorCode: d.SUBSCRIBE_TIMEOUT.code, errorMessage: _(d.SUBSCRIBE_TIMEOUT) }])), this._requires_ack(s), this._schedule_message(s) }, v.prototype.unsubscribe = function (e, t) { if (this._trace("Client.unsubscribe", e, t), !this.connected) throw new Error(_(d.INVALID_STATE, ["not connected"])); var s = new p(c.UNSUBSCRIBE); s.topics = [e], t.onSuccess && (s.callback = function () { t.onSuccess({ invocationContext: t.invocationContext }) }), t.timeout && (s.timeOut = new w(this, window, t.timeout, t.onFailure, [{ invocationContext: t.invocationContext, errorCode: d.UNSUBSCRIBE_TIMEOUT.code, errorMessage: _(d.UNSUBSCRIBE_TIMEOUT) }])), this._requires_ack(s), this._schedule_message(s) }, v.prototype.send = function (e) { if (this._trace("Client.send", e), wireMessage = new p(c.PUBLISH), wireMessage.payloadMessage = e, this.connected) e.qos > 0 ? this._requires_ack(wireMessage) : this.onMessageDelivered && (this._notify_msg_sent[wireMessage] = this.onMessageDelivered(wireMessage.payloadMessage)), this._schedule_message(wireMessage); else { if (!this._reconnecting || !this.disconnectedPublishing) throw new Error(_(d.INVALID_STATE, ["not connected"])); if (Object.keys(this._sentMessages).length + this._buffered_msg_queue.length > this.disconnectedBufferSize) throw new Error(_(d.BUFFER_FULL, [this.disconnectedBufferSize])); e.qos > 0 ? this._requires_ack(wireMessage) : (wireMessage.sequence = ++this._sequence, this._buffered_msg_queue.push(wireMessage)) } }, v.prototype.disconnect = function () { if (this._trace("Client.disconnect"), this._reconnecting && (this._reconnectTimeout.cancel(), this._reconnectTimeout = null, this._reconnecting = !1), !this.socket) throw new Error(_(d.INVALID_STATE, ["not connecting or connected"])); wireMessage = new p(c.DISCONNECT), this._notify_msg_sent[wireMessage] = u(this._disconnected, this), this._schedule_message(wireMessage) }, v.prototype.getTraceLog = function () { if (null !== this._traceBuffer) { this._trace("Client.getTraceLog", new Date), this._trace("Client.getTraceLog in flight messages", this._sentMessages.length); for (var e in this._sentMessages) this._trace("_sentMessages ", e, this._sentMessages[e]); for (var e in this._receivedMessages) this._trace("_receivedMessages ", e, this._receivedMessages[e]); return this._traceBuffer } }, v.prototype.startTrace = function () { null === this._traceBuffer && (this._traceBuffer = []), this._trace("Client.startTrace", new Date, "@VERSION@") }, v.prototype.stopTrace = function () { delete this._traceBuffer }, v.prototype._doConnect = function (e) { if (this.connectOptions.useSSL) { var t = e.split(":"); t[0] = "wss", e = t.join(":") } this._wsuri = e, this.connected = !1, this.connectOptions.mqttVersion < 4 ? this.socket = new WebSocket(e, ["mqttv3.1"]) : this.socket = new WebSocket(e, ["mqtt"]), this.socket.binaryType = "arraybuffer", this.socket.onopen = u(this._on_socket_open, this), this.socket.onmessage = u(this._on_socket_message, this), this.socket.onerror = u(this._on_socket_error, this), this.socket.onclose = u(this._on_socket_close, this), this.sendPinger = new I(this, window, this.connectOptions.keepAliveInterval), this.receivePinger = new I(this, window, this.connectOptions.keepAliveInterval), this._connectTimeout && (this._connectTimeout.cancel(), this._connectTimeout = null), this._connectTimeout = new w(this, window, this.connectOptions.timeout, this._disconnected, [d.CONNECT_TIMEOUT.code, _(d.CONNECT_TIMEOUT)]) }, v.prototype._schedule_message = function (e) { this._msg_queue.push(e), this.connected && this._process_queue() }, v.prototype.store = function (e, t) { var s = { type: t.type, messageIdentifier: t.messageIdentifier, version: 1 }; switch (t.type) { case c.PUBLISH: t.pubRecReceived && (s.pubRecReceived = !0), s.payloadMessage = {}; for (var n = "", i = t.payloadMessage.payloadBytes, o = 0; o < i.length; o++)i[o] <= 15 ? n = n + "0" + i[o].toString(16) : n += i[o].toString(16); s.payloadMessage.payloadHex = n, s.payloadMessage.qos = t.payloadMessage.qos, s.payloadMessage.destinationName = t.payloadMessage.destinationName, t.payloadMessage.duplicate && (s.payloadMessage.duplicate = !0), t.payloadMessage.retained && (s.payloadMessage.retained = !0), 0 === e.indexOf("Sent:") && (void 0 === t.sequence && (t.sequence = ++this._sequence), s.sequence = t.sequence); break; default: throw Error(_(d.INVALID_STORED_DATA, [key, s])) }localStorage.setItem(e + this._localKey + t.messageIdentifier, JSON.stringify(s)) }, v.prototype.restore = function (e) { var t = localStorage.getItem(e), s = JSON.parse(t), n = new p(s.type, s); switch (s.type) { case c.PUBLISH: for (var i = s.payloadMessage.payloadHex, o = new ArrayBuffer(i.length / 2), r = new Uint8Array(o), a = 0; i.length >= 2;) { var h = parseInt(i.substring(0, 2), 16); i = i.substring(2, i.length), r[a++] = h } var u = new Paho.MQTT.Message(r); u.qos = s.payloadMessage.qos, u.destinationName = s.payloadMessage.destinationName, s.payloadMessage.duplicate && (u.duplicate = !0), s.payloadMessage.retained && (u.retained = !0), n.payloadMessage = u; break; default: throw Error(_(d.INVALID_STORED_DATA, [e, t])) }0 === e.indexOf("Sent:" + this._localKey) ? (n.payloadMessage.duplicate = !0, this._sentMessages[n.messageIdentifier] = n) : 0 === e.indexOf("Received:" + this._localKey) && (this._receivedMessages[n.messageIdentifier] = n) }, v.prototype._process_queue = function () { for (var e = null, t = this._msg_queue.reverse(); e = t.pop();)this._socket_send(e), this._notify_msg_sent[e] && (this._notify_msg_sent[e](), delete this._notify_msg_sent[e]) }, v.prototype._requires_ack = function (e) { var t = Object.keys(this._sentMessages).length; if (t > this.maxMessageIdentifier) throw Error("Too many messages:" + t); for (; void 0 !== this._sentMessages[this._message_identifier];)this._message_identifier++; e.messageIdentifier = this._message_identifier, this._sentMessages[e.messageIdentifier] = e, e.type === c.PUBLISH && this.store("Sent:", e), this._message_identifier === this.maxMessageIdentifier && (this._message_identifier = 1) }, v.prototype._on_socket_open = function () { var e = new p(c.CONNECT, this.connectOptions); e.clientId = this.clientId, this._socket_send(e) }, v.prototype._on_socket_message = function (e) { this._trace("Client._on_socket_message", e.data); for (var t = this._deframeMessages(e.data), s = 0; s < t.length; s += 1)this._handleMessage(t[s]) }, v.prototype._deframeMessages = function (e) { var s = new Uint8Array(e), n = []; if (this.receiveBuffer) { var i = new Uint8Array(this.receiveBuffer.length + s.length); i.set(this.receiveBuffer), i.set(s, this.receiveBuffer.length), s = i, delete this.receiveBuffer } try { for (var o = 0; o < s.length;) { var r = t(s, o), a = r[0]; if (o = r[1], null === a) break; n.push(a) } o < s.length && (this.receiveBuffer = s.subarray(o)) } catch (e) { var c = "undefined" == e.hasOwnProperty("stack") ? e.stack.toString() : "No Error Stack Available"; return void this._disconnected(d.INTERNAL_ERROR.code, _(d.INTERNAL_ERROR, [e.message, c])) } return n }, v.prototype._handleMessage = function (e) { this._trace("Client._handleMessage", e); try { switch (e.type) { case c.CONNACK: if (this._connectTimeout.cancel(), this._reconnectTimeout && this._reconnectTimeout.cancel(), this.connectOptions.cleanSession) { for (var t in this._sentMessages) { I = this._sentMessages[t]; localStorage.removeItem("Sent:" + this._localKey + I.messageIdentifier) } this._sentMessages = {}; for (var t in this._receivedMessages) { f = this._receivedMessages[t]; localStorage.removeItem("Received:" + this._localKey + f.messageIdentifier) } this._receivedMessages = {} } if (0 !== e.returnCode) { this._disconnected(d.CONNACK_RETURNCODE.code, _(d.CONNACK_RETURNCODE, [e.returnCode, l[e.returnCode]])); break } this.connected = !0, this.connectOptions.uris && (this.hostIndex = this.connectOptions.uris.length); o = []; for (var s in this._sentMessages) this._sentMessages.hasOwnProperty(s) && o.push(this._sentMessages[s]); if (this._buffered_msg_queue.length > 0) for (var n = null, i = this._buffered_msg_queue.reverse(); n = i.pop();)o.push(n), this.onMessageDelivered && (this._notify_msg_sent[n] = this.onMessageDelivered(n.payloadMessage)); for (var o, r = 0, a = (o = o.sort(function (e, t) { return e.sequence - t.sequence })).length; r < a; r++) { if ((I = o[r]).type == c.PUBLISH && I.pubRecReceived) { u = new p(c.PUBREL, { messageIdentifier: I.messageIdentifier }); this._schedule_message(u) } else this._schedule_message(I) } this.connectOptions.onSuccess && this.connectOptions.onSuccess({ invocationContext: this.connectOptions.invocationContext }); var h = !1; this._reconnecting && (h = !0, this._reconnectInterval = 1, this._reconnecting = !1), this._connected(h, this._wsuri), this._process_queue(); break; case c.PUBLISH: this._receivePublish(e); break; case c.PUBACK: (I = this._sentMessages[e.messageIdentifier]) && (delete this._sentMessages[e.messageIdentifier], localStorage.removeItem("Sent:" + this._localKey + e.messageIdentifier), this.onMessageDelivered && this.onMessageDelivered(I.payloadMessage)); break; case c.PUBREC: if (I = this._sentMessages[e.messageIdentifier]) { I.pubRecReceived = !0; var u = new p(c.PUBREL, { messageIdentifier: e.messageIdentifier }); this.store("Sent:", I), this._schedule_message(u) } break; case c.PUBREL: var f = this._receivedMessages[e.messageIdentifier]; localStorage.removeItem("Received:" + this._localKey + e.messageIdentifier), f && (this._receiveMessage(f), delete this._receivedMessages[e.messageIdentifier]); var g = new p(c.PUBCOMP, { messageIdentifier: e.messageIdentifier }); this._schedule_message(g); break; case c.PUBCOMP: I = this._sentMessages[e.messageIdentifier]; delete this._sentMessages[e.messageIdentifier], localStorage.removeItem("Sent:" + this._localKey + e.messageIdentifier), this.onMessageDelivered && this.onMessageDelivered(I.payloadMessage); break; case c.SUBACK: (I = this._sentMessages[e.messageIdentifier]) && (I.timeOut && I.timeOut.cancel(), 128 === e.returnCode[0] ? I.onFailure && I.onFailure(e.returnCode) : I.onSuccess && I.onSuccess(e.returnCode), delete this._sentMessages[e.messageIdentifier]); break; case c.UNSUBACK: var I; (I = this._sentMessages[e.messageIdentifier]) && (I.timeOut && I.timeOut.cancel(), I.callback && I.callback(), delete this._sentMessages[e.messageIdentifier]); break; case c.PINGRESP: this.sendPinger.reset(); break; case c.DISCONNECT: this._disconnected(d.INVALID_MQTT_MESSAGE_TYPE.code, _(d.INVALID_MQTT_MESSAGE_TYPE, [e.type])); break; default: this._disconnected(d.INVALID_MQTT_MESSAGE_TYPE.code, _(d.INVALID_MQTT_MESSAGE_TYPE, [e.type])) } } catch (e) { var w = "undefined" == e.hasOwnProperty("stack") ? e.stack.toString() : "No Error Stack Available"; return void this._disconnected(d.INTERNAL_ERROR.code, _(d.INTERNAL_ERROR, [e.message, w])) } }, v.prototype._on_socket_error = function (e) { this._reconnecting || this._disconnected(d.SOCKET_ERROR.code, _(d.SOCKET_ERROR, [e.data])) }, v.prototype._on_socket_close = function () { this._reconnecting || this._disconnected(d.SOCKET_CLOSE.code, _(d.SOCKET_CLOSE)) }, v.prototype._socket_send = function (e) { if (1 == e.type) { var t = this._traceMask(e, "password"); this._trace("Client._socket_send", t) } else this._trace("Client._socket_send", e); this.socket.send(e.encode()), this.sendPinger.reset() }, v.prototype._receivePublish = function (e) { switch (e.payloadMessage.qos) { case "undefined": case 0: this._receiveMessage(e); break; case 1: var t = new p(c.PUBACK, { messageIdentifier: e.messageIdentifier }); this._schedule_message(t), this._receiveMessage(e); break; case 2: this._receivedMessages[e.messageIdentifier] = e, this.store("Received:", e); var s = new p(c.PUBREC, { messageIdentifier: e.messageIdentifier }); this._schedule_message(s); break; default: throw Error("Invaild qos=" + wireMmessage.payloadMessage.qos) } }, v.prototype._receiveMessage = function (e) { this.onMessageArrived && this.onMessageArrived(e.payloadMessage) }, v.prototype._connected = function (e, t) { this.onConnected && this.onConnected(e, t) }, v.prototype._reconnect = function () { this._trace("Client._reconnect"), this.connected || (this._reconnecting = !0, this.sendPinger.cancel(), this.receivePinger.cancel(), this._reconnectInterval < 128 && (this._reconnectInterval = 2 * this._reconnectInterval), this.connectOptions.uris ? (this.hostIndex = 0, this._doConnect(this.connectOptions.uris[0])) : this._doConnect(this.uri)) }, v.prototype._disconnected = function (e, t) { if (this._trace("Client._disconnected", e, t), void 0 !== e && this._reconnecting) this._reconnectTimeout = new w(this, window, this._reconnectInterval, this._reconnect); else if (this.sendPinger.cancel(), this.receivePinger.cancel(), this._connectTimeout && (this._connectTimeout.cancel(), this._connectTimeout = null), this._msg_queue = [], this._buffered_msg_queue = [], this._notify_msg_sent = {}, this.socket && (this.socket.onopen = null, this.socket.onmessage = null, this.socket.onerror = null, this.socket.onclose = null, 1 === this.socket.readyState && this.socket.close(), delete this.socket), this.connectOptions.uris && this.hostIndex < this.connectOptions.uris.length - 1) this.hostIndex++ , this._doConnect(this.connectOptions.uris[this.hostIndex]); else if (void 0 === e && (e = d.OK.code, t = _(d.OK)), this.connected) { if (this.connected = !1, this.onConnectionLost && this.onConnectionLost({ errorCode: e, errorMessage: t, reconnect: this.connectOptions.reconnect, uri: this._wsuri }), e !== d.OK.code && this.connectOptions.reconnect) return this._reconnectInterval = 1, void this._reconnect() } else 4 === this.connectOptions.mqttVersion && !1 === this.connectOptions.mqttVersionExplicit ? (this._trace("Failed to connect V4, dropping back to V3"), this.connectOptions.mqttVersion = 3, this.connectOptions.uris ? (this.hostIndex = 0, this._doConnect(this.connectOptions.uris[0])) : this._doConnect(this.uri)) : this.connectOptions.onFailure && this.connectOptions.onFailure({ invocationContext: this.connectOptions.invocationContext, errorCode: e, errorMessage: t }) }, v.prototype._trace = function () { if (this.traceFunction) { for (var e in arguments) void 0 !== arguments[e] && arguments.splice(e, 1, JSON.stringify(arguments[e])); var t = Array.prototype.slice.call(arguments).join(""); this.traceFunction({ severity: "Debug", message: t }) } if (null !== this._traceBuffer) for (var e = 0, s = arguments.length; e < s; e++)this._traceBuffer.length == this._MAX_TRACE_ENTRIES && this._traceBuffer.shift(), 0 === e ? this._traceBuffer.push(arguments[e]) : void 0 === arguments[e] ? this._traceBuffer.push(arguments[e]) : this._traceBuffer.push("  " + JSON.stringify(arguments[e])) }, v.prototype._traceMask = function (e, t) { var s = {}; for (var n in e) e.hasOwnProperty(n) && (s[n] = n == t ? "******" : e[n]); return s }; var E = function (e, t, s, n) { var i; if ("string" != typeof e) throw new Error(_(d.INVALID_TYPE, [typeof e, "host"])); if (2 == arguments.length) { n = t; var o = (i = e).match(/^(wss?):\/\/((\[(.+)\])|([^\/]+?))(:(\d+))?(\/.*)$/); if (!o) throw new Error(_(d.INVALID_ARGUMENT, [e, "host"])); e = o[4] || o[2], t = parseInt(o[7]), s = o[8] } else { if (3 == arguments.length && (n = s, s = "/mqtt"), "number" != typeof t || t < 0) throw new Error(_(d.INVALID_TYPE, [typeof t, "port"])); if ("string" != typeof s) throw new Error(_(d.INVALID_TYPE, [typeof s, "path"])); var r = -1 !== e.indexOf(":") && "[" !== e.slice(0, 1) && "]" !== e.slice(-1); i = "ws://" + (r ? "[" + e + "]" : e) + ":" + t + s } for (var a = 0, c = 0; c < n.length; c++) { var u = n.charCodeAt(c); 55296 <= u && u <= 56319 && c++ , a++ } if ("string" != typeof n || a > 65535) throw new Error(_(d.INVALID_ARGUMENT, [n, "clientId"])); var l = new v(i, e, t, s, n); this._getHost = function () { return e }, this._setHost = function () { throw new Error(_(d.UNSUPPORTED_OPERATION)) }, this._getPort = function () { return t }, this._setPort = function () { throw new Error(_(d.UNSUPPORTED_OPERATION)) }, this._getPath = function () { return s }, this._setPath = function () { throw new Error(_(d.UNSUPPORTED_OPERATION)) }, this._getURI = function () { return i }, this._setURI = function () { throw new Error(_(d.UNSUPPORTED_OPERATION)) }, this._getClientId = function () { return l.clientId }, this._setClientId = function () { throw new Error(_(d.UNSUPPORTED_OPERATION)) }, this._getOnConnected = function () { return l.onConnected }, this._setOnConnected = function (e) { if ("function" != typeof e) throw new Error(_(d.INVALID_TYPE, [typeof e, "onConnected"])); l.onConnected = e }, this._getDisconnectedPublishing = function () { return l.disconnectedPublishing }, this._setDisconnectedPublishing = function (e) { l.disconnectedPublishing = e }, this._getDisconnectedBufferSize = function () { return l.disconnectedBufferSize }, this._setDisconnectedBufferSize = function (e) { l.disconnectedBufferSize = e }, this._getOnConnectionLost = function () { return l.onConnectionLost }, this._setOnConnectionLost = function (e) { if ("function" != typeof e) throw new Error(_(d.INVALID_TYPE, [typeof e, "onConnectionLost"])); l.onConnectionLost = e }, this._getOnMessageDelivered = function () { return l.onMessageDelivered }, this._setOnMessageDelivered = function (e) { if ("function" != typeof e) throw new Error(_(d.INVALID_TYPE, [typeof e, "onMessageDelivered"])); l.onMessageDelivered = e }, this._getOnMessageArrived = function () { return l.onMessageArrived }, this._setOnMessageArrived = function (e) { if ("function" != typeof e) throw new Error(_(d.INVALID_TYPE, [typeof e, "onMessageArrived"])); l.onMessageArrived = e }, this._getTrace = function () { return l.traceFunction }, this._setTrace = function (e) { if ("function" != typeof e) throw new Error(_(d.INVALID_TYPE, [typeof e, "onTrace"])); l.traceFunction = e }, this.connect = function (e) { if (e = e || {}, h(e, { timeout: "number", userName: "string", password: "string", willMessage: "object", keepAliveInterval: "number", cleanSession: "boolean", useSSL: "boolean", invocationContext: "object", onSuccess: "function", onFailure: "function", hosts: "object", ports: "object", reconnect: "boolean", mqttVersion: "number", mqttVersionExplicit: "boolean", uris: "object" }), void 0 === e.keepAliveInterval && (e.keepAliveInterval = 60), e.mqttVersion > 4 || e.mqttVersion < 3) throw new Error(_(d.INVALID_ARGUMENT, [e.mqttVersion, "connectOptions.mqttVersion"])); if (void 0 === e.mqttVersion ? (e.mqttVersionExplicit = !1, e.mqttVersion = 4) : e.mqttVersionExplicit = !0, void 0 !== e.password && void 0 === e.userName) throw new Error(_(d.INVALID_ARGUMENT, [e.password, "connectOptions.password"])); if (e.willMessage) { if (!(e.willMessage instanceof y)) throw new Error(_(d.INVALID_TYPE, [e.willMessage, "connectOptions.willMessage"])); if (e.willMessage.stringPayload = null, void 0 === e.willMessage.destinationName) throw new Error(_(d.INVALID_TYPE, [typeof e.willMessage.destinationName, "connectOptions.willMessage.destinationName"])) } if (void 0 === e.cleanSession && (e.cleanSession = !0), e.hosts) { if (!(e.hosts instanceof Array)) throw new Error(_(d.INVALID_ARGUMENT, [e.hosts, "connectOptions.hosts"])); if (e.hosts.length < 1) throw new Error(_(d.INVALID_ARGUMENT, [e.hosts, "connectOptions.hosts"])); for (var t = !1, n = 0; n < e.hosts.length; n++) { if ("string" != typeof e.hosts[n]) throw new Error(_(d.INVALID_TYPE, [typeof e.hosts[n], "connectOptions.hosts[" + n + "]"])); if (/^(wss?):\/\/((\[(.+)\])|([^\/]+?))(:(\d+))?(\/.*)$/.test(e.hosts[n])) { if (0 === n) t = !0; else if (!t) throw new Error(_(d.INVALID_ARGUMENT, [e.hosts[n], "connectOptions.hosts[" + n + "]"])) } else if (t) throw new Error(_(d.INVALID_ARGUMENT, [e.hosts[n], "connectOptions.hosts[" + n + "]"])) } if (t) e.uris = e.hosts; else { if (!e.ports) throw new Error(_(d.INVALID_ARGUMENT, [e.ports, "connectOptions.ports"])); if (!(e.ports instanceof Array)) throw new Error(_(d.INVALID_ARGUMENT, [e.ports, "connectOptions.ports"])); if (e.hosts.length !== e.ports.length) throw new Error(_(d.INVALID_ARGUMENT, [e.ports, "connectOptions.ports"])); e.uris = []; for (n = 0; n < e.hosts.length; n++) { if ("number" != typeof e.ports[n] || e.ports[n] < 0) throw new Error(_(d.INVALID_TYPE, [typeof e.ports[n], "connectOptions.ports[" + n + "]"])); var o = e.hosts[n], r = e.ports[n], a = -1 !== o.indexOf(":"); i = "ws://" + (a ? "[" + o + "]" : o) + ":" + r + s, e.uris.push(i) } } } l.connect(e) }, this.subscribe = function (e, t) { if ("string" != typeof e) throw new Error("Invalid argument:" + e); if (t = t || {}, h(t, { qos: "number", invocationContext: "object", onSuccess: "function", onFailure: "function", timeout: "number" }), t.timeout && !t.onFailure) throw new Error("subscribeOptions.timeout specified with no onFailure callback."); if (void 0 !== t.qos && 0 !== t.qos && 1 !== t.qos && 2 !== t.qos) throw new Error(_(d.INVALID_ARGUMENT, [t.qos, "subscribeOptions.qos"])); l.subscribe(e, t) }, this.unsubscribe = function (e, t) { if ("string" != typeof e) throw new Error("Invalid argument:" + e); if (t = t || {}, h(t, { invocationContext: "object", onSuccess: "function", onFailure: "function", timeout: "number" }), t.timeout && !t.onFailure) throw new Error("unsubscribeOptions.timeout specified with no onFailure callback."); l.unsubscribe(e, t) }, this.send = function (e, t, s, n) { var i; if (0 === arguments.length) throw new Error("Invalid argument.length"); if (1 == arguments.length) { if (!(e instanceof y) && "string" != typeof e) throw new Error("Invalid argument:" + typeof e); if (void 0 === (i = e).destinationName) throw new Error(_(d.INVALID_ARGUMENT, [i.destinationName, "Message.destinationName"])); l.send(i) } else (i = new y(t)).destinationName = e, arguments.length >= 3 && (i.qos = s), arguments.length >= 4 && (i.retained = n), l.send(i) }, this.publish = function (e, t, s, n) { console.log("Publising message to: ", e); var i; if (0 === arguments.length) throw new Error("Invalid argument.length"); if (1 == arguments.length) { if (!(e instanceof y) && "string" != typeof e) throw new Error("Invalid argument:" + typeof e); if (void 0 === (i = e).destinationName) throw new Error(_(d.INVALID_ARGUMENT, [i.destinationName, "Message.destinationName"])); l.send(i) } else (i = new y(t)).destinationName = e, arguments.length >= 3 && (i.qos = s), arguments.length >= 4 && (i.retained = n), l.send(i) }, this.disconnect = function () { l.disconnect() }, this.getTraceLog = function () { return l.getTraceLog() }, this.startTrace = function () { l.startTrace() }, this.stopTrace = function () { l.stopTrace() }, this.isConnected = function () { return l.connected } }; E.prototype = { get host() { return this._getHost() }, set host(e) { this._setHost(e) }, get port() { return this._getPort() }, set port(e) { this._setPort(e) }, get path() { return this._getPath() }, set path(e) { this._setPath(e) }, get clientId() { return this._getClientId() }, set clientId(e) { this._setClientId(e) }, get onConnected() { return this._getOnConnected() }, set onConnected(e) { this._setOnConnected(e) }, get disconnectedPublishing() { return this._getDisconnectedPublishing() }, set disconnectedPublishing(e) { this._setDisconnectedPublishing(e) }, get disconnectedBufferSize() { return this._getDisconnectedBufferSize() }, set disconnectedBufferSize(e) { this._setDisconnectedBufferSize(e) }, get onConnectionLost() { return this._getOnConnectionLost() }, set onConnectionLost(e) { this._setOnConnectionLost(e) }, get onMessageDelivered() { return this._getOnMessageDelivered() }, set onMessageDelivered(e) { this._setOnMessageDelivered(e) }, get onMessageArrived() { return this._getOnMessageArrived() }, set onMessageArrived(e) { this._setOnMessageArrived(e) }, get trace() { return this._getTrace() }, set trace(e) { this._setTrace(e) } }; var y = function (e) { var t; if (!("string" == typeof e || e instanceof ArrayBuffer || e instanceof Int8Array || e instanceof Uint8Array || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array || e instanceof Float64Array)) throw _(d.INVALID_ARGUMENT, [e, "newPayload"]); t = e, this._getPayloadString = function () { return "string" == typeof t ? t : a(t, 0, t.length) }, this._getPayloadBytes = function () { if ("string" == typeof t) { var e = new ArrayBuffer(o(t)), s = new Uint8Array(e); return r(t, s, 0), s } return t }; var s; this._getDestinationName = function () { return s }, this._setDestinationName = function (e) { if ("string" != typeof e) throw new Error(_(d.INVALID_ARGUMENT, [e, "newDestinationName"])); s = e }; var n = 0; this._getQos = function () { return n }, this._setQos = function (e) { if (0 !== e && 1 !== e && 2 !== e) throw new Error("Invalid argument:" + e); n = e }; var i = !1; this._getRetained = function () { return i }, this._setRetained = function (e) { if ("boolean" != typeof e) throw new Error(_(d.INVALID_ARGUMENT, [e, "newRetained"])); i = e }; var c = !1; this._getDuplicate = function () { return c }, this._setDuplicate = function (e) { c = e } }; return y.prototype = { get payloadString() { return this._getPayloadString() }, get payloadBytes() { return this._getPayloadBytes() }, get destinationName() { return this._getDestinationName() }, set destinationName(e) { this._setDestinationName(e) }, get topic() { return this._getDestinationName() }, set topic(e) { this._setDestinationName(e) }, get qos() { return this._getQos() }, set qos(e) { this._setQos(e) }, get retained() { return this._getRetained() }, set retained(e) { this._setRetained(e) }, get duplicate() { return this._getDuplicate() }, set duplicate(e) { this._setDuplicate(e) } }, { Client: E, Message: y } }(window) });
